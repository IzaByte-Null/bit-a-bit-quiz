(setup inicial)
decisão: separei a lógica em apps para não dar bosta:usuariosa a autenticação, quiz para o jogo.

 #Modularidade pura, ou #SeparaçãoDePreocupações (SoC). se a lógica do jogo rebentar, a cena de login está safe e não preciso  mexer em tudo ao mesmo tempo.

 o calcanhar de aquiles (nomenclatura url)
problema fdd: levei com um NoReverseMatch: Reverse for 'principal_page' not found.

rastreio: o erro estava no redirect() da view de assinatura. eu tinha metido name='principal' no urls.py, 

regra: o django só quer saber do nome! o nome no redirect() e o nome no path;têm de ser #IDÊNTICOS. o erro prova que ele não procura o URL (/principal/), ele procura o nome. por isso, #RoteamentoNomeado 

   premium (assinatura e controlo de acesso)
 preciso de um campo is_assinante, mas não posso tocar no modelo User do django.

soluçao#ExtensãoDeModelo. criei o modelo Perfil (usuarios.models.Perfil) com uma chave OneToOneField ligada ao User. é ali que guardo cenas específicas da minha app (tipo o status da assinatura).

comprafake: a assinatura_page_view. usei o redirect('principal') logo a seguir ao POST. isto é o #PRG (Post/Redirect/Get) – crucial para  não reenviar a "compra" se fizer refresh.

o guardião (o gatekeeper)
 lógica: usei o @login_required para mandar o usuariopara o loggin caso n conter autentificaçao 

feature gating no backend: dentro da pagina_chatbot_premium, a regra é clara: if not request.user.perfil.is_assinante: return redirect('principal'). isto é o #ControleDeAcesso (ou #FeatureGating para engenharia de software). se não o "papel" premium, fica errado.real é sempre bloqueado aqui, no backend (o mais seguro).

erro  (again): mesmo corrigindo no python, levei com outro NoReverseMatch. a culpa era do template! eu tinha {% url 'principal_page' %} no HTML

 a consistência do nome é #VITAL em todo o lado /python E templates

 a ponte (integração ia/chatbot)
endpoint:  criar o api_chatbot_responder como uma api_view(['POST'])

design da api:  #DesignRESTful. o cliente usa POST (para mandar os dados, ou seja, a pergunta) e a API devolve um JSON. o DRF facilita esta cena

segurança e personalidade na ia
prompting: usei o system_instruction  "voce e um assistente de T.I" engenhariaDePrompts,  só dar o contexto certo para a IA se comportar corretamente

frontend mágico (ajax): meti o fetch() no chatbot.html (o #AJAX, ou #Assincronicidade). isto manda a pergunta sem recarregar a página, tipo um chat a sério

a segurança da api é tudo: meti o getCookie('csrftoken') no cabeçalho X-CSRFToken do fetch.

 nota muito importante: sem este token nas requisições POST (que mudam dados), o django bloqueia a TUDO /prevenir #CSRFProtection (ataques maliciosos de outros sites). nunca esquecer isto numa api

último bug: o layout estava uma confusão. o javascript só controla o que tem id. se tiver tags html estáticas, ele duplica tudo.  só elementos que o javascript manipula (com id), tiro os estáticos.

próximos passos (to do)
layout: acabar o chatbot.css para as mensagens ficarem bonitas (bot à esquerda, user à direita).

perfil auto: implementar um #DjangoSignal para garantir que o perfil é criado sempre que um novo User e criado. assim evito o erro Perfil.DoesNotExist que aparece quando vou ver o status de assinatura.

quiz: começar a lógica do jogo (carregar perguntas, calcular pontuação, etc.).

fotos: criar o forms.py para validar a alteração de imagem de perfil (para o user conseguir mudar a foto).